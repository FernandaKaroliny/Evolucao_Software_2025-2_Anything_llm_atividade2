# -*- coding: utf-8 -*-
"""all_mini_lm_l6_v2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aKAjkUmvhzacHkWdNwpNx2hgvqbvZKMp
"""

# Instalar dependências
!pip install -q sentence-transformers scikit-learn

# Importar bibliotecas
from sentence_transformers import SentenceTransformer
from sklearn.cluster import KMeans
import numpy as np


# Carregar modelo All-MiniLM-L6-v2 ------------------------------
model = SentenceTransformer('all-MiniLM-L6-v2')


# Ler arquivo entrada5.txt ------------------------------
with open('entrada5.txt', 'r', encoding='utf-8') as f:
    entrada = f.read()


linhas = [linha.strip() for linha in entrada.split('\n') if linha.strip()]


# Separar manualmente seções de branches e releases ---------------------------
branches = []
releases = []
modo = None
for linha in linhas:
    if linha.lower().startswith("branches"):
        modo = "branches"
        continue
    if linha.lower().startswith("releases"):
        modo = "releases"
        continue
    if modo == "branches":
        branches.append(linha)
    elif modo == "releases":
        releases.append(linha)


# Gerar embeddings ------------------------------
branch_embeddings = model.encode(branches)
release_embeddings = model.encode(releases)


# Agrupar releases e branches com KMeans ------------------------------
# Releases: cluster 2 (features vs patches)
kmeans_release = KMeans(n_clusters=2, random_state=42)
release_clusters = kmeans_release.fit_predict(release_embeddings)

# Branches: cluster 3 (master, features, bugs)
kmeans_branch = KMeans(n_clusters=3, random_state=42)
branch_clusters = kmeans_branch.fit_predict(branch_embeddings)


# Interpretar clusters para estratégia ------------------------------
# Releases
num_patches = sum(1 for c in release_clusters if c == 0)
num_features = sum(1 for c in release_clusters if c == 1)
if num_patches > 0 and num_features > 0:
    estrategia_releases = "Rapid Release (entregas frequentes de patches e features)"
else:
    estrategia_releases = "Release Train / LTS (poucos releases grandes ou regulares)"

# Branches
# Identificação simples baseada em nomes
master_branch = any("master" in b.lower() for b in branches)
feature_branch = any("feat" in b.lower() for b in branches)
bug_branch = any("bug" in b.lower() for b in branches)
if master_branch and feature_branch and bug_branch:
    fluxo_trabalho = "Gitflow simplificado (master para produção, branches curtas para features e bugs)"
else:
    fluxo_trabalho = "GitHub Flow (merge direto em master)"


# Resultados ------------------------------
print("=== Releases agrupados ===")
for r, c in zip(releases, release_clusters):
    print(f"[Cluster {c}] {r}")

print("\n=== Branches agrupados ===")
for b, c in zip(branches, branch_clusters):
    print(f"[Cluster {c}] {b}")

print("\n=== Estratégia de Releases sugerida ===")
print(estrategia_releases)

print("\n=== Modelo de Fluxo de Trabalho sugerido ===")
print(fluxo_trabalho)